관계형 DB와 SQL

기업에서 가장 많이 사용되는 DB, 관계형 DB

데이터는 21세기의 원유라고 표현한다. 잠재가치가 크다.

과거에는 데이터가 일부 전문가들만 다루는 영역이었고 일반인에게는 생소한 개념이었다.
하지만 지금은 대용향 처리 기술 인터넷 발달로 빅데이터의 시대가 도래하였다.
이제는 IT전문가뿐만 아니라 영업관리자, 마케터, 서비스 기획자 등 비전공 실무자들도 데이터 분야에 관심을 갖게 되었다.

영업팀에 근무한다고 가정했을 때 매출 데이터와 분석결과로 보고서를 작성해야 할 때 먼저 데이터가 있어야만 한다. 데이터는
1, 관련부서(IT부서)
2, 직접 DB에서 구해야 한다.

SQL을 알고 있다면 단 몇 줄의 쿼리문을 사용하여 원하는 데이터를 몇 분 안에 추출할 수 있다.


데이터 분석과정
1. 문제인식
2. 데이터 수집/가공 (SQL/전처리)
3. 데이터 분석 (R/Python)
4. 분석 결과 (보고서/회의)

전체 과정에서 전처리(pre-precessing 결측치, 이상치)가 70~80%를 차지한다.

데이터의 종류 :
정형 structured data
비정형 unstructured data

정형 - 틀이 잡혀 있는 데이터, 체계화된 데이터
	안정성이 높다, 유연성이 낮다.
	금융, 제조 등 대부분의 기업의 데이터 (엑셀, CSV...)
	관계형 데이터베이스로 관리 가능
비정형 - 틀이 잡혀있지 않은 사전 정의가 없는 다양하고 방대한 데이터
	텍스트 (facebook, twitter), 이미지, 음원 등

데이터베이스란?
데이터는 어떤 것들의 '기록된 정보'이고 이러한 데이터를 모아서 관리하는 것이 DB이다.

관계형 데이터베이스란?************
현재 업무용으로 가장 많이 사용되는 방식이고 역사가 오래되었음에도 지속적으로 발전해 나가고 있는 데이터베이스다. MySQL, MSSQL, Oracle, IBM, Asscess 등

열(column)과 행(row)로 이루어진 2차원 테이블을 중심으로 설계된 데이터 베이스이다.
테이블들이 key와 관계라는 연결 고리로 연결되어 원하는 데이터를 조회하고 가공하는 방식의 DB이다.

계층형 데이터베이스

Root - Level 1
       - Level 1 - Level 2
                    - Level 2
 
객체지향 데이터베이스
데이터도 객체 모델로 관리

 객체 A     <->      객체 B
     l       객체 C       ㅣ
 객체 D                객체 E


 데이터베이스
주로 인터넷에서 데이터를 관리하는 용도로 사용된다. (파이썬의 dict, 자바의 map, JS json)

SQL?
SQL은 관계형 데이터베이스를 조작하기 위해 만든 표준언어로 DBMS와 통신하기 위한 언어이다.

사용사 -> SQL -> DBMS -> DB

SQL의 특징
1. 사용하기 쉽다.
2. 절차가 없는 비절차적 언어다.
3. 관계형 DB를 조작한다.
4. 표준 언어이다.

SQL 종류

DML 조작어 Data Manipulation Language : SELECT, INSERT, UPDATE, DELETE
DDL 정의어 Data Definition Language : CREATE, ALTER, DROP, RENAME
DCL 제어어 Data Control Language : GRANT, REVOKE
TCL 트랜젝션 컨트롤 Transaction Control Language : COMMIT, ROLLBACK

sql로 데이터 처리 (추출/수집/가공)을 하여 데이터를 검색하고 분석한다.

관계형 데이터베이스의 구성요소
1) 테이블 뷰 인덱스 등으로 구성된다.
2) 데이터를 저장하고 그 데이터들의 관계의 집합이다.
3) 일관성, 정확성, 신뢰성을 위한 트랜젝션, 무결성 등의 개념이 존재한다.

테이블 : 가장 많이 다루는 행과 열로 구성된 저장 단위
	데이터베이스의 다양한 구성 요소 중에서 데이터를 담는 그릇이라 할 수 있는 테이블을
	가장 많이 사용하게 된다.
	데이터베이스를 한 마디를 요약하면 테이블들이 모여 있는 집합이라 할 수 있다.
	테이블은 행 row 열 column 으로 이루너진 엑셀과 비슷하다.

SQL Developer
1 접속(좌상단) DB 정보 테이블/뷰 등의 객체 정보가 계층형태로 보여진다. DB의 전체 구조를 알 수 있다.
2. 보고서 (좌하단) 데이터 모델링과 구조 보안 성능 등 모니터링과 보고서를 확인하는 영역 주로 DB관리자 시스템 담당자가 보는 화면으로 초반에는 사용할 일이 거의 없다.
3. 편집(우상단) SQL문을 작성하는 편집 영역이다. 이 창에서 SQL문을 작성하게 된다. 작성할 때 발생되는 문법 오류 등을 알려준다.
4. 출력(우하단) SQL문의 실행 결과 등이 출력되는 영역이다.

별도의 ID HR password 1234 생성
ALTER USER HR ACCOUNT UNLOCK IDENTIFIED BY 1234;

SELECT 
데이터를 조회하는 데 필요한 거의 모든 기능을 제공한다.
SELECT을 사용하여 행을 선택하고 열을 선택하고 테이블과 테이블을 연결할 수 있다.
SELECT문은 데이터를 조회하고 분석하는 데 가장 기본이며 중요한 SQL 구문이다.

SELECT문은 항상 FROM과 함께 사용된다. 다른 조건 추가가 필요하면 WHERE절에 기록하고 데이터가 출력되는 순서를 조정하려면 ORDER BY를 사용한다.

SELECT (열 이름들 OR *전체) <- 가져올 열들 또는 열 또는 전체
FROM (테이블명)                <- 어느 테이블로부터
[WHERE (조건식)] <- 선택
[ORDER BY (열이름 ASC or DESC)];

1. SQL 구문은 모두 항상 대문자로 입력한다.
2. [ ] 안의 항목은 선택사항으로 생략 가능하다.
3. 구문의 끝은 세미콜론 ; 을 입력한다. (생략 가능할 때도 있다)
4. 한 줄 또는 여러 줄을 사용하든 상관하지 않는다.
5. 들여쓰기도 상관하지 않는다.

SELECT 는 데이터를 선택한다는 의미이다. 단지 선택만 할 뿐 그 결과값이 데이터베이스에 반영되는 것은 아니다.
SELECT * <- 출력하려는 열이 '모든 열' 이라는 의미
FROM employees; <- 어느 테이블로부터 라는 의미

'employees'라는 테이블로부터 모든 열을 조회하라

SELECT employee_id, first_name, last_name
FROM employees;

SELECT 명령문 뒤에 나열한 열들의 이름 순으로 조회된다. 열들의 이름은 ,를 사용하여 계속 붙일 수 있고 결과는 나열한 순서대로 출력된다.

모든 열 * 을 대신하여 모든 열의 이름을 모두 적으면 같은 결과가 나오게 된다.

ORDER BY 열이름 [ASC or DESC] <- DESC 내림차순

SELECT employee_id, first_name, last_name
FROM employees
ORDER BY employee_id DESC; <- employee_id 값을 기준으로 내림차순 DESC 정렬

ORDER BY 명령문에 아무것도 지정하지 않으면 오름차순 정렬되기 때문에 
ORDER BY employee_id ASC; 와 같다.

ORDER BY 열이름, 열이름 DESC, 열이름 ASC  식으로 정렬하고 싶은 열을 계속 지정할 수 있다.

중복값 제거하고 출력 DISTINCT
SELECT DISTINCT job_id
FROM employees;

DISTINCT를 사용하면 데이터 값이 종류별로 하나씩만 출력된 것을 볼 수 있다.


별명 사용하기
SELECT문의 결과를 출력할 때 일반적으로 열 이름은 테이블을 정의할 때 명명한 열의 제목을 출력한다. 원래의 열 이름 외의 이름으로 쓰고자 할 때 사용하는 것이 별칭(ALIES)이다.
1) 열 이름을 임시로 변경하는 데 사용된다. 원래의 이름은 물리적으로 변경되는 것이 아니다.
2) 별칭은 열 이름 바로 뒤에 사용하며 AS를 사용한다.
3) AS는 생략 가능하다.

SELECT employee_id as 사원번호, first_name AS 이름
FROM employees;

데이터값 연결 - 각 열에 따로 담겨 있는 데이터를 하나로 붙이거나 추가 서식을 붙여 활용할 수 있다.
	         || 연결 연산자 2개
	         [열 이름] || [열 이름]    [열 이름] || '문자'

SELECT employee_id, first_name || last_name
FROM employees;

SELECT employee_id, first_name || ' ' || last_name
FROM employees;

SELECT email || '@' || 'naver.com' AS email
FROM employees;


데이터 값끼리 연산
SELECT employee_id, salary, salary +500, salary - 100
FROM employees;


조건절을 활용한 데이터 검색 WHERE

행의 특정 데이터 값을 조회하거나 비교하여 연산처리하는 방법
'어디에서 어떻게' 가져올지를 결정한다. WHERE는 FROM 다음에 위치하며 조건식을 포함한다.
1) 조건을 지정하고
2) FROM 절 다음에 위치한다.
3) 조건절에는 비교연산자 논리연산자 표현식 문자 숫자 등을 사용한다.

SELECT 열 이름
FROM 테이블 이름
WHERE 조건식;

SELECT *
FROM employees
WHERE employee_id = 100; <- 조건이 숫자

SELECT *
FROM employees
WHERE first_name = 'David'; <- 조건이 문자

# 'David' 'david'는 다른 의미이다.


SELECT *
FROM employees
WHERE employee_id >= 100;

BETWEEN a AND b 두 값의 범위에 해당하는 행들을검색

SELECT *
FROM employees
WHERE salary BETWEEN 10000 AND 20000;

IN 조회하고자 하는 데이터 값이 여러 개일 때 사용한다.
    = 과 비슷하지만 = 은 하나만 지정하지만 IN은 여러 개를 지정할 수 있다.

SELECT *
FROM employees
WHERE salary IN (10000, 17000, 24000);
LIKE 조건값이 명확하지 않을 때 '~와 같은'
1) % 와 _같은 기호 연산자와 함께 사용된다.
2) 조건에는 문자나 숫자가 포함된다.
3) %는 모든 문자의 의미이고 _는 '한 글자'를 의미한다.

SELECT *
FROM employees
WHERE job_id LIKE 'AD%';
# 맨 앞에 AD를 포함하면 뒤에는 몇 개가 오든 어떤 글자가 오든 출력한다.

SELECT *
FROM employees
WHERE job_id LIKE 'AD___';
# 맨 앞에 AD를 포함하고 뒤에는 반드시 3글자인 데이터만 출력


IS NULL 데이터의 값이 null인 경우를 조회할 때 사용한다.
null은 공백이 아니고 0도 아니다. 공백은 문자이다.

SELECT *
FROM employees
WHERE manager_id IS NULL;

SELECT *
FROM employees
WHERE salary > 4000
AND job_id = 'IT_PROG';

AND는 주어진 조건들을 모두 만족

SELECT *
FROM employees
WHERE salary > 4000
OR job_id = 'IT_PROG';

OR는 주어진 조건 중 하나만 만족해도 전부 만족

NOT  != 같지 않다. <> 같지 않다 (ISO 표준)

SELECT *
FROM employees
WHERE job_id <> 'IT_PROG';

#함수
입력 -> 함수 -> 출력
input               output
딸기     믹서기   딸기주스

y = 2X + 1  X = 2, y = 5

1) 데이터값을 계산하거나 조작한다.
2) 행의 그룹에 대해 계산하거나 요약한다.

함수에는 단일행 함수와 그룹함수가 있다.
단일행 함수 : 한 번에 하나만 처리, a1값을 처리하고 a2값을 처리
그룹함수 : 동시에 대상 열 전체 처리, d1, d2, d3, d4를 동시에 입력받아 평균, 합계 등을 출력
그룹함수는 GROUP BY 절과 함께 사용된다.

단일행함수에 많이 사용되는 데이터 타입을 보면
CHAR(n) 문자, 고정길이
VARCHAR(n) 문자, 가변길이
숫자 NUMBER() 숫자 타입
날짜 DATE() 날짜 타입

단일행 함수들은 테이블에 존재하는 많은 행들이 한 번에 하나씩만 입력되어 하나씩 처리되는 함수이다.
1) 각 행에 대해 수행한다.
2) 각 데이터타입에 맞는 함수를 사용해야 한다.
3) 행별로 하나의 결과를 반환한다.
4) 중첩해서 사용할 경우 가장 안쪽 단계에서 바깥쪽 단계로 진행된다.
함수1(함수2(함수3))
1)함수3 >> 2)함수2 >> 3)함수1

문자 타입함수는 주로 데이터 조작에 쓰이고 문자나 문자열 데이터는 작은 따옴표를 사용하여 표현한다.

lower() : 값을 소문자로 변환한다.
	lower('ABCD')  ->   abdc
upper() : 값을 대문자로 변환한다.
	upper('abcd')   ->  ABCD 
initcap() : 첫 글자만 대문자로 변환한다.
	initcap('abcd')   ->  Abcd
substr() : 문자열들 중에서 일부분만 선택한다.
	substr('ABC', 1,2)  ->  AB (SQL은 미만도, 시작이 1이다)
replace() : 특정 문자열을 찾아 바꾼다. 
	replace('AB','A','E')    -> EB (A를 E로 바꿔라)
concat() : 두 문자열을 연결한다. ( || 와 같다)
	concat('ABC', 'DEF')   -> ABCDEF
length() 문자열의 길이를 구한다.
	length('AB')            -> 2
instr() :  문자의 위치를 구한다.
	instr('ABCD', 'D')      -> 4
lpad() : 왼쪽부터 특정 문자로 자리를 채운다.
	lpad('ABCD',6,'*')     -> **ABCD
총 6개의 자리를 만들고 왼쪽부터 *로 나머지를 채운다
	lpad('78',3,'0')        -> 078
rpad() : 오른쪽부터 특정 문자로 자리를 채운다.
	rpad('ABCD',6,'*')     -> ABCD**
ltrim() : 문자열의 왼쪽 문자를 지운다.
	ltrim('ABCD','AB')     -> CD
	ltrim('  ABCD', '  ')   -> ABCD
rtrim() : 문자열의 오른쪽 문자를 지운다.
	ltrim('ABCD','CD')     -> AB

SELECT last_name, 
    LOWER(last_name) LOWER적용,
    UPPER(last_name) UPPER적용,
    email,
    INITCAP(email) INITCAP적용
FROM employees;

첫 글자만 대문자였던 last_name 열의 값이 LOWER 함수를 적용하면 모두 소문자로 바뀐다.
또한 원래 대문자였던 email 열의 INITCAP 함수를 적용하자 첫 글자만 대문자로 변경된 것을 볼 수 있다.

#SUBSTR : 지정된 길이만큼 문자열 추출하기

SELECT job_id, SUBSTR(job_id, 1, 2)
FROM employees;

SUBSTR('문자열', 시작위치, 길이)

REPLACE 특정 문자를 찾아 바꾸기
SELECT job_id, REPLACE(job_id,'ACCOUNT','ACCNT')
FROM employees;

LPAD
SELECT first_name, LPAD(first_name, 12, '*')
FROM employees;

employees 테이블에서 job_id의 값에 대해 왼쪽 방향부터 'F'를 만나면 삭제
SELECT job_id, LTRIM(job_id, 'F')
FROM employees;

TRIM 공백을 모두 제거, 문자열 중간의 여백은 제거 불가

DUAL 테이블 dummy라는 하나의 열과 X 데이터 값을 갖는 테이블이다.
별 의미 없이 테이블을 문법적으로 지정해야 할 때 사용하는 테이블이다.
SELECT * FROM dual;



# 숫자 타입 함수
숫자 타입 함수들은 주로 숫자를 계산하거나 계산이 끝난 뒤에 추가로 가공처리를 할 때 사용한다. (반올림 등)

round : 반올림
	round(15.351, 0) -> 15
	round(15.751, 0) -> 16

trunc : 숫자를 절삭한다.
	trunc(15.351,1)   -> 15.3

mod : 나누고 나서 나머지만 취한다. java의 % 연산자
	홀수 짝수 배수
	mod(15,2)          ->  1

sign() : 양수(1), 음수(-1), 0(0)인지 구분한다.
	sign(15)             -> 1

반올림 round
1   2   3  .  4  5  6
-3 -2  -1 0  1  2  3

SELECT salary,
	salary/30 일급
FROM employees;

SELECT salary,
    ROUND(salary/30,-1) MINUS1적용,
    ROUND(salary/30, 0) ZERO적용,
    ROUND(salary/30, 1) PLUS1적용,
    salary/30 일급
FROM employees;

TRUNC 지정한 숫자 자리에서 숫자를 절삭(버림) 기본 문법은 ROUND와 동일하다.
SELECT salary,
    TRUNC(salary/30,-1) MINUS1적용,
	TRUNC(salary/30, 0) ZERO적용,
    TRUNC(salary/30, 1) PLUS1적용,
    salary/30 일급
FROM employees;


변환함수

각 열에 대해 데이터 타입을 규정하고 있다. 따라서 SQL문을 실행하기 위해 데이터 값의 타입을 변환해야 할 때도 있다. 
데이터베이스 시스템에 의해 자동으로(암시적으로) 또는 사용자에 의해 수동으로(명시적으로) 실행될 수 있다.

자동 형변환

VARCHAR / CAHR - > NUMBER
VARCHAR / CAHR - > DATE

SELECT 1 + '2' (자동 형변환)
FROM dual;
'2'는 작은 따옴표로 묶여 있으므로 숫자가 아닌 문자이다. 그럼에도 불구하고 결과는 3이라고 바르게 계산되어 출력되었다. DBMS이 계산을 위해 문자 '2'를 자동으로 숫자 2로 변환하여 계산하였다. 이것을 데이터베이스 시스템에 의한 자동 데이터 타입 변환이라고 한다.
그렇지만 자동 데이터 타입 변환을 이용할 수 있더라도 SQL문의 성능과 안정성을 위해 수동 데이터 타입변환을 수행하는 것이 좋다.

수동 데이터 타입 변환

TO_CHAR 숫자/문자/날짜를 VARCHAR로 변환
TO_NUMBER 문자를 숫자로 변환
TO_DATE 형태만 날짜인 문자열을 날짜로 변환

SELECT TO_CHAR(SYSDATE, 'YY')
FROM dual;

SELECT TO_CHAR(SYSDATE, 'YY'),
        TO_CHAR(SYSDATE, 'YYYY'),
        TO_CHAR(SYSDATE, 'MM'),
        TO_CHAR(SYSDATE, 'MON'),
        TO_CHAR(SYSDATE, 'YYYYMMDD') 응용적용1
FROM dual;

SELECT TO_CHAR(SYSDATE, 'HH:MI:SS PM') 시간형식,
        TO_CHAR(SYSDATE, 'YYYY/MM/DD HH:MI:SS PM') 날짜시간함께
FROM dual;

SELECT TO_CHAR(SYSDATE, 'HH:MI:SS PM') 시간형식,
        TO_CHAR(SYSDATE, 'YYYY/MM/DD HH:MI:SS PM') 날짜시간함께,
        TO_CHAR(SYSDATE, '"날짜: "YYYY/MM/DD "시각: "HH:MI:SS PM') 날짜시간표현
FROM dual;
'안에 "가 들어감

TO_NUMBER 숫자처럼 보이는 문자열을 진짜 숫자 데이터 타입으로 변환하는 함수


데이터를 조작하거나 프로그래밍할 때 자주 쓰는 함수들을 살펴보자

NOT NULL 특정 열의 행에 대한 데이터 값이 없다면 데이터 값은 NULL이 된다. NULL 값이 '아무것도 없다'는 것을 나타내는 값이다.
테이블을 만들 때 null값을 가지지 못하도록 지정할 수도 있다.

null의 특징
1) 함수 적용이 불가능한 값이다.
2) 0도 아니고 공백 ' ' 아니다.
3) null값을 포함하여 계산한 결과는 null이다. 0*5 = 0이듯이

SELECT *
FROM employees
ORDER BY commission_pct;

commission_pct 에 대해 오름차순으로 정렬하여 출력된다.
36행부터는 데이터의 값이 null이다.

SELECT salary * commission_pct
FROM employees
ORDER BY commission_pct;

null이 있는 36행부터는 null로 처리된다.
















