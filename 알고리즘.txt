알고리즘
문제나 과제를 해결하기 위한 처리 절차를 구체적인 순서에 따라 표현한 생각

알고리즘을 구체화 -> 악보/ 그림 등등
- flowchart?

알고리즘 -> 프로그래밍 언어로 구체화 -> 프로그램
알고리즘은 설계 단계에서 필요

문서화
변수명/요소 등 담은 문서

- 좋은 알고리즘
이해하기에도, 알기에도 쉽다.
속도가 빠르다.
효율적이다 -> 프로그램 실행할 때 사용하는 메모리의 영역이 작다
재이용하기 쉽다 -> 만든 것을 모듈화 (회원관리  게시판)

빠르고 효율적 범용성(재이용)이 높다

알고리즘 구조 종류 - 순차, 선택(if), 반복(while, for)

탐색 알고리즘
 - 선형 알고리즘, 효율이 좋지 않다. 처음부터 순서대로 찾는다.

 - 이진 탐색법, 내림차순/오름차순으로 정렬이 되어 있어야 찾을 수 있다. 탐색 범위를 반으로 줄여나가는 탐색법
-> (평균)->첫 숫자+마지막 숫자/2   (head+tail)/2
-> 가운데 요소를 선택, 데이터를 비교, 탐색 범위를 반으로 줄인다( /= ?)
보통 소수점은 버리기로 처리한다.

원하는 데이터가 center보다 큰 경우, head는 center + 1이 되어야 한다. -> tail은 그대로
원하는 데이터가 center보다 작은 경우, tail는 center - 1이 되어야 한다. -> head는 그대로

- 해시 탐색법, 미리 찾기 쉽게 저장해야 한다. -> 찾는 시간이 매우 빠르다.
-> 데이터의 내용과 저장한 곳의 요소를 미리 연계(24번은 24번 배열에 넣어놓는 것) 
-> 배열이 낭비된다. (효율성이 떨어진다) But, 일정한 규칙으로 계산(%칸의 수)해서 배정 -> 나머지 값으로 배정
즉, 공을 넣은 칸의 번호 = 공의 숫자 % 칸의 전체 수. 그러나 첨자가 중복될 수 있다.

배열을 두 개 준비 -> 수를 넣어두는 배열(배열 들어갈 수 만큼 칸 준비), 실제로 저장할 배열(일정한 수로 초기화, 배열 칸 수는 1.5~2배가 적당) 
빈 방인지 확인(초기화값인지?) 후 대입
빈 방이 아니라면 나머지에 +1 을 하여 해당하는 수의 방에 대입. 끝까지 빈 방이 없다면 처음부터 저장

정렬 알고리즘
오름차순/내림차순으로 정렬하는 알고리즘
- 단순 선택법, 제일 작은 것부터 정렬. 제일 작은 것을 앞으로 보내는 것. 오름차순으로

에라토스테네스의 체, 유클리드 알고리즘.